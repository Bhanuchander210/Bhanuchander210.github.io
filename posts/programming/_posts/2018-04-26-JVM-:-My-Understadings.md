### Overview

Before start, Just think about any process in a machine should be tracked and all parameters
about the execution should be stored for reference. 

<p class="quickNote"><b>Example :</b>
In any sports, First we need to set a platform, ground for the play and all players need to get in their 
initial position (or) formation. Before starting to play all the initial rules are checked, If any thing is out of the rule Game could not be started until it corrected. 

Before starting the game what are all we have,

- All players data
- Formation or Position
- Player role
- The Game rule

Once all the initial rules are checked, then only the game can be started.
</p>
<p class="noteHeader">Not only sports anywhere and every work process we can see the methodology to manage and track the process of our work</p>

In JVM Also we are having these methodology process and some special areas for organizing and executing the machine code 
which got from **Java Byte Code**. 

> If you are not familiar with java just take a look my <a class="link" href="https://github.com/Bhanuchander210/Learn_Java">Learn_java</a>   

So we know that all **java codes** compiled into *class files* and executed by the **JVM**. This post discuss with the JVM
Architecture and *How it works?*.
 
### JVM - Architecture
<hr>


<kbd class="imgtitle">JVM Block Diagram</kbd>

![JVM-Arch](/images/post_img/JVM-Architecture.png)
{: .imgbrd }

### JVM - How it works
<hr>

### Class Loader Subsystem
<hr>

Javaâ€™s dynamic class loading functionality is handled by the class loader subsystem. It loads, links and initializes the class when it refers to a class for the first time at runtime, not at compile-time. It performs three major functionality such as Loading, Linking, and Initialization.

###### 1. Loading 

Classes will be loaded by this component. BootStrap ClassLoader, Extension ClassLoader, Application ClassLoader are the three class loader which will help in achieving it.

- <p class="noteHeader">1. BootStrap ClassLoader</p>
    Responsible for loading classes from the bootstrap classpath, nothing but <mark>rt.jar</mark> Highest priority will be given to this loader.
- <p class="noteHeader">2. Extension ClassLoader</p>
    Responsible for loading classes which are inside ext folder <mark>jre\lib</mark>
- <p class="noteHeader">3. Application ClassLoader</p>
    Responsible for loading Application Level Classpath, path mentioned Environment Variable etc.

The above Class Loaders will follow <mark>Delegation Hierarchy Algorithm</mark> while loading the class files.

###### 2. Linking

1. Verify
Bytecode verifier will verify whether the generated bytecode is proper or not if verification fails we will get verification error.

2. Prepare 
For all static variables memory will be allocated and assigned with default values.

3. Resolve 
All symbolic memory references are replaced with the original references from Method Area.

###### 3. Initialization

This is the final phase of Class Loading, here all static variable will be assigned with the original values and static block will be executed.

### Runtime Data Area
<hr>

Runtime Data Area is divided into 5 major components

- **Method Area :**
    All the Class level data will be stored here including static variables. Method Area is one per JVM and it is a shared resource.
    
- **Heap Area :**
    All the Objects and its corresponding instance variables and arrays will be stored here. Heap Area is also one per JVM since Method area and Heap area shares memory for multiple threads the data stored is not thread safe.

- **Stack Area :**
    For every thread, a separate runtime stack will be created. For every method call, one entry will be made in the stack memory which is called as Stack Frame. All local variables will be created in the stack memory. Stack area is thread safe since it is not a shared resource. Stack Frame is divided into three sub-entities such as

- **Local Variable Array :**
    Related to the method how many local variables are involved and the corresponding values will be stored here.

- **Operand stack :** 
    If any intermediate operation is required to perform, operand stack act as runtime workspace to perform the operation.

- **Frame data :**
    All symbols corresponding to the method is stored here. In the case of any exception, the catch block information will be maintained in the frame data.

- **PC Registers :**
    Each thread will have separate PC Registers, to hold address of current executing instruction once the instruction is executed the PC register will be updated with the next instruction

- **Native Method stacks :**
    Native Method Stack holds native method information. For every thread, separate native method stack will be created.

### Execution Engine
<hr>

The bytecode which is assigned to the Runtime Data Area will be executed by the Execution Engine. The Execution Engine reads the byte code and executes one by one.

###### Interpreter

Reads the bytecode, interprets it and executes it one by one. The interpreter interprets the bytecode faster but executes slowly. The disadvantage of the interpreter is that when one method called multiple times, every time interpretation is required.

###### JIT Compiler
JIT Compiler neutralizes the disadvantage of the Interpreter ( a single method called multiple times, each time interpretation is required ), The Execution Engine will be using the help of Interpreter in converting but when it found repeated code it uses JIT compiler which compiles the entire bytecode and changes it to native code.  This native code will be used directly for repeated method calls which improve the performance of the system.

- **Intermediate Code generator :**
    produces intermediate code.

- **Code Optimizer :**
    Code Optimizer is responsible for optimizing the intermediate code generated above.

- **Target Code Generator :**
    Target Code Generator is responsible for Generating Machine Code/ Native Code

- **Profiler :** 
    Profiler is a special component, it is responsible for finding the hot spots (i.e) Used to identify whether the method is called multiple time or not.

###### Garbage Collector 
Garbage Collector is a part of Execution Engine, it collects/removes the unreferenced objects. Garbage Collection can be triggered by calling <mark>System.gc()</mark>, but the execution is not guaranteed. Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup.

###### Java Native Interface (JNI)  
JNI will be interacting with the Native Method Libraries and provides the Native Libraries required for the Execution Engine.

###### Native Method Libraries 
It is a Collection of the Native Libraries which is required for the Execution Engine.

### Importance of Garbage Collection Roots
<hr>

Every object tree must have one or more root objects. 
As long as the application can reach those roots, the whole tree is reachable. 
But when are those root objects considered reachable? Special objects called **garbage-collection roots** are always 
reachable and so is any object that has a garbage-collection root at its own root.

It means that which objects are all reachable from **GC Roots**, that are in live..!
{: .noteHeader}

<kbd class="imgtitle">GC Root</kbd>

![img](/images/post_img/class_loaders.jpg)
{: .imgbrd}


###### Four kind of GC roots in Java:

- **Local variables :** These are kept alive by the stack of a thread. This is not a real object virtual reference and thus is not visible. For all intents and purposes, local variables are GC roots.
- **Active Java threads :** These are always considered live objects and are therefore GC roots. This is especially important for thread local variables.
- **Static variables :** These are referenced by their classes. This fact makes them a kind GC roots. 
Classes themselves can be garbage-collected, which would remove all referenced static variables. This is of special importance when we use application servers, OSGi containers or class loaders in general.
We will discuss the related problems in the Problem Patterns section.

- **JNI References :** These are Java objects that the native code has created as part of a JNI call. 
Objects thus created are treated specially because the JVM does not know if it is being referenced by the native code or not.